#!/usr/bin/perl -w
#
# POD currently doesn't support any sort of =include directive.  This processor
# works around that limitation.  Currently, only single include nesting is
# supported.  The included file is not processed for additional =include
# statements. The include paths are taken to be relative to the directory
# containing the file being processed.
#
# Usage: merge-pod <input-file> [<input-file> ...]
#        merge-pod
#
# The first form takes a list of file paths ending in .in as its arguments and
# processes any POD directives of the form =include <file> in that file,
# generating a file with the .in suffix removed. The output file is written to
# the same directory as the input file.
#
# When no input files are given, merge-pod scans the pod<n> directories
# relative to the path of the merge-pod script itself for files ending in
# *.in. For each input file file found, merge-pod processes any POD
# directives of the form =include <file> in that file, generating an output
# file with the .in suffix removed in the pod<n> directory in the current
# working directory.  The pod<n> directories are created in the current
# directory if not already present.

require 5.00503;

use Cwd qw(getcwd);
use File::Basename qw(dirname basename);
use File::Spec::Functions qw(catfile);
use Getopt::Long;

my %VARIABLE = ();

# Remove leading and trailing whitespace from a string.
sub trim {
    my $s = shift;
    $s =~ s/^\s+//g;
    $s =~ s/\s+$//g;
    return $s
};

# Load the subsititution variables from a file.
sub load_variables {
    my $variable_file = shift;
    my $line = 0;

    open(V, "< $variable_file") or die "Cannot open $variable_file: $!";
    while (<V>) {
        $line++;
        chomp;
        next if /^#/;     # Skip comment lines.
        next if /^\s*$/;  # Skip blank lines.
        unless (/=/) {
            die "$0: Missing '=' in $variable_file line $line.\n";
        }
        my ($name, $value) = split(/=/, $_, 2);
        $name = trim($name);
        $value = trim($value);
        $VARIABLE{$name} = $value;
    }
    close(V);
}

# Lookup a substitution varialble or fail with a error message.
sub lookup_variable {
    my $name = shift;
    my $file = shift;
    my $line = shift;

    if (not exists $VARIABLE{$name}) {
        die "$0: Unknown variable \@${name}\@ at $file line $line.\n";
    }
    return $VARIABLE{$name};
}


sub merge_pod {
    my ($file, $out) = @_;
    my $start = getcwd;
    my $dir = dirname ($file);
    my $line = 1;

    open (FILE, "< $file") or die "cannot open $file: $!\n";
    binmode FILE, ':crlf' if $^O eq 'MSWin32';
    binmode FILE, ':crlf' if $^O eq 'cygwin';
    open (OUT, "> $out") or die "cannot open $out: $!\n";
    chdir $dir or die "cannot chdir to $dir: $!\n";
    local $_;
    while (<FILE>) {
        if (/^=include\s+(\S+)/) {
            my $include_file = $1;
            my $include_line = 1;
            open (INCLUDE, "< $include_file") or die "cannot open $include_file: $!\n";
            while (<INCLUDE>) {
                s/\@(\w+)\@/lookup_variable($1, $include_file, $include_line)/age;
                print OUT $_ or die "cannot write to $out: $!\n";
                $include_line++;
            }
            close INCLUDE or die "cannot read from $1: $!\n";
        } else {
            s/\@(\w+)\@/lookup_variable($1, $file, $line)/age;
            print OUT $_ or die "cannot write to $out: $!\n";
            $line++;
        }
    }
    close OUT or die "cannot write to $out: $!\n";
    close FILE or die "cannot read from $file\n";
    chdir $start or die "cannot chdir to $start: $!\n";
}

my $variable_file;
GetOptions(
    "variable-file=s" => \$variable_file,
) or die("Error while parsing options.\n");

if (defined $variable_file) {
    load_variables($variable_file);
}

if (scalar(@ARGV) > 0) {
    for my $file (@ARGV) {
        $file =~ s:\\:/:g if $^O eq 'cygwin';
        my $out = $file;
        unless ($out =~ s/\.in\z//) {
            die "input file $file does not end in .in\n";
        }
        merge_pod($file, $out);
    }
} else {
    my $srcdir = dirname(__FILE__);
    for my $section (qw(1 3 5 8)) {
        unless (-d "pod${section}") {
            mkdir("pod${section}", 0755) or
                die "Cannot create pod${section} directory: $!\n";
        }
        my $dir = catfile($srcdir, "pod${section}");
        opendir(D, $dir) or die "Cannot open $dir: $!\n";
        for my $file (readdir(D)) {
            if ($file =~ /\.in\z/) {
                my $input = catfile($srcdir, "pod${section}", $file);
                my $output = catfile("pod${section}", $file);
                $output =~ s/\.in\z//;
                merge_pod($input, $output);
            }
        }
    }
}
